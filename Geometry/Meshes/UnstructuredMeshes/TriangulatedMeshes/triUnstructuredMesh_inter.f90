module triUnstructuredMesh_inter

  use numPrecision
  use universalVariables,     only : INF
  use genericProcedures,      only : append, findCommon, findDifferent, hasDuplicates, removeDuplicates
  use coord_class,            only : coord
  use dictionary_class,       only : dictionary
  use pyramidShelf_class,     only : pyramidShelf
  use tetrahedron_class,      only : tetrahedron
  use tetrahedronShelf_class, only : tetrahedronShelf
  use triangle_class,         only : triangle
  use triangleShelf_class,    only : triangleShelf
  use unstructuredMesh_inter, only : unstructuredMesh, kill_super => kill
  use vertex_class,           only : vertex

  implicit none
  private

  ! Extendable procedures.
  public :: distanceToBoundaryFace, distanceToNextFace, findElementAndParentIdxs, kill

  !! Abstract interface to group all triangulated unstructured meshes. A triangulated unstructured mesh is an
  !! unstructured mesh whose faces have been decomposed into triangles and elements into tetrahedra.
  !!
  !! Public members:
  !!   pyramids                  -> Shelf that stores pyramids (intermediate products of decomposition).
  !!   tetrahedra                -> Shelf that stores tetrahedra.
  !!   triangles                 -> Shelf that stores triangles.
  !!
  !! Interface:
  !!   computePrimitives         -> Computes the number of primitive elements (triangles, pyramids and tetrahedra)
  !!                                to be generated during decomposition process.
  !!   distanceToBoundaryFace    -> Checks if a particle enters the mesh and returns distance to entry 
  !!                                intersection.
  !!   distanceToNextFace        -> Returns the distance to the next mesh face.
  !!   findElementAndParentIdxs  -> Returns the index of the mesh element occupied by a particle. Also
  !!                                returns the index of the parent mesh element containing the occupied
  !!                                element.
  !!   findTetrahedronFromEdge   -> Returns the index of the mesh tetrahedron occupied by a particle when the
  !!                                particle is on a tetrahedron's edge.
  !!   findTetrahedronFromFace   -> Returns the index of the mesh tetrahedron occupied by a particle when the
  !!                                particle is on a tetrahedron's face.
  !!   findTetrahedronFromVertex -> Returns the index of the mesh tetrahedron occupied by a particle when the
  !!                                particle is on a tetrahedron's vertex.
  !!   kill                      -> Returns to an unitialised state.
  !!   replaceVertexShelf        -> Replaces the current vertexShelf of the mesh with a new shelf containing more 
  !!                                vertices.
  !!   split                     -> Splits the elements of the mesh into tetrahedra and the faces into triangles.
  !!   splitElements             -> Splits the elements of the mesh into pyramids.
  !!   splitPyramids             -> Splits the pyramids generated by splitElements into tetrahedra.
  !!
  type, public, abstract, extends(unstructuredMesh) :: triUnstructuredMesh
    private
    type(pyramidShelf), public                      :: pyramids
    type(tetrahedronShelf), public                  :: tetrahedra
    type(triangleShelf), public                     :: triangles
  contains
    procedure, non_overridable                      :: computePrimitives
    procedure                                       :: distanceToBoundaryFace
    procedure                                       :: distanceToNextFace
    procedure                                       :: findElementAndParentIdxs
    procedure, non_overridable                      :: findTetrahedronFromEdge
    procedure, non_overridable                      :: findTetrahedronFromFace
    procedure, non_overridable                      :: findTetrahedronFromVertex
    procedure                                       :: kill
    procedure, non_overridable                      :: replaceVertexShelf
    procedure, non_overridable                      :: split
    procedure, non_overridable                      :: splitElements
    procedure, non_overridable                      :: splitPyramids
  end type triUnstructuredMesh

contains

  !! Subroutine 'computePrimitives'
  !!
  !! Basic description:
  !!   Computes the number of pyramids, triangles and tetrahedra to be created during the mesh
  !!   splitting process.
  !!
  !! Detailed description:
  !!   The number of pyramids is simply given by the sum of the number of faces in each element in
  !!   the original element. The number of triangles is more complex: each pyramid created during
  !!   the splitting process also creates a number of triangles equal to the number of edges (or
  !!   vertices) in the current face. However, since all these triangles are internal they are
  !!   always shared between two pyramids; therefore, the number of triangles to be generated during
  !!   the pyramid creation process is, for a given element, equal to the sum of the number of
  !!   vertices in each of the element's face divided by two. Triangles are also created during the
  !!   splitting of the original mesh's faces: for a given face, the number of triangles to be
  !!   created is simply equal to the number of vertices in the face less two. Lastly, during the
  !!   splitting of pyramids into tetrahedra, additional internal triangles are created, given by
  !!   the number of vertices in a given pyramid's base less three. The number of tetrahedra to be
  !!   generated simply is, for a given face, the number of triangles it is decomposed into.
  !!
  !! Arguments:
  !!   nPyramids [out]   -> Number of pyramids to be generated.
  !!   nTriangles [out]  -> Number of triangles to be generated.
  !!   nTetrahedra [out] -> Number of tetrahedra to be generated.
  !!
  elemental subroutine computePrimitives(self, nPyramids, nTriangles, nTetrahedra)
    class(triUnstructuredMesh), intent(in)       :: self
    integer(shortInt), intent(out)               :: nPyramids, nTriangles, nTetrahedra
    integer(shortInt)                            :: i, j, nVertices, nFaces, nVerticesInFace, &
                                                    absFaceIdx
    integer(shortInt), dimension(:), allocatable :: faceIdxs

    ! Initialise nPyramids, nTetrahedra and nTriangles and loop through all elements.
    nPyramids = 0
    nTetrahedra = 0
    nTriangles = 0
    do i = 1, self % nElements
      ! Retrieve the number of vertices and indices of the faces in the current element.
      nVertices = size(self % elements % shelf(i) % getVertices())
      faceIdxs = self % elements % shelf(i) % getFaces()
      
      ! Check if the current element is already a tetrahedron. If yes, increment nTetrahedra by 1
      ! and nTriangles by the number of triangles owned by the tetrahedron then cycle.
      if (nVertices == 4) then
        nTetrahedra = nTetrahedra + 1
        nTriangles = nTriangles + count(faceIdxs > 0)
        cycle
      
      end if   

      ! Compute the number of faces in the current element.
      nFaces = size(faceIdxs)
      
      ! Since there is one pyramid per element face, increase nPyramids by nFaces.
      nPyramids = nPyramids + nFaces
      
      ! Initialise nVertices and loop through all faces.
      nVertices = 0
      do j = 1, nFaces
        absFaceIdx = abs(faceIdxs(j))
        ! Retrieve the number of vertices in the current face and increase the total 
        ! number of vertices by the number of vertices in the current face.
        nVerticesInFace = size(self % faces % shelf(absFaceIdx) % getVertices())
        nVertices = nVertices + nVerticesInFace
        
        ! Increase the number of triangles corresponding to new internal faces by nVerticesInFace - 3.
        nTriangles = nTriangles + nVerticesInFace - 3

        ! If the element owns the current face, increase the number of triangles by nVerticesInFace - 2.
        if (faceIdxs(j) > 0) nTriangles = nTriangles + nVerticesInFace - 2
        
        ! There will be as many tetrahedra as the number of triangles in each face, which is given
        ! by nVerticesInFace - 2.
        nTetrahedra = nTetrahedra + nVerticesInFace - 2
      
      end do
      
      ! The number of pyramids' faces is given by half the total number of vertices.
      nTriangles = nTriangles + nVertices / 2

    end do

  end subroutine computePrimitives

  !! Subroutine 'distanceToBoundaryFace'
  !!
  !! Basic description:
  !!   Returns the distance to the mesh boundary face intersected by a particle's path. Also returns the index
  !!   of the parent element containing the intersected boundary face.
  !!
  !! See mesh_inter for details.
  !!
  pure subroutine distanceToBoundaryFace(self, d, coords, parentIdx)
    class(triUnstructuredMesh), intent(in) :: self
    real(defReal), intent(out)             :: d
    type(coord), intent(inout)             :: coords
    integer(shortInt), intent(out)         :: parentIdx

    ! Initialise parentIdx = 0 then search the tree for the intersected boundary triangle. Update parentIdx only
    ! if boundary intersection has been found.
    parentIdx = 0
    call self % tree % findIntersectedTriangle(d, coords, self % vertices, self % triangles)
    if (coords % elementIdx > 0) parentIdx = self % tetrahedra % shelf(coords % elementIdx) % getElement()

  end subroutine distanceToBoundaryFace

  !! Subroutine 'distanceToNextFace'
  !!
  !! Basic description:
  !!   Returns the distance to the next triangle intersected by the particle's path. Returns
  !!   INF if the particle does not intersect any triangle (i.e., if its path is entirely
  !!   contained in the tetrahedron the particle currently is). Algorithm adapted from Macpherson, 
  !!   et al. (2009). DOI: 10.1002/cnm.1128.
  !!
  !! See mesh_inter for details.
  !!
  !! TODO: Optimise this.
  pure subroutine distanceToNextFace(self, d, coords)
    class(triUnstructuredMesh), intent(in)       :: self
    real(defReal), intent(out)                   :: d
    type(coord), intent(inout)                   :: coords
    real(defReal), dimension(3)                  :: r, rEnd
    integer(shortInt)                            :: intersectedTriangleIdx, oldElement, newElement
    integer(shortInt), dimension(:), allocatable :: potentialTriangles, triangleToTetrahedra
    real(defReal)                                :: lambda
    type(tetrahedron)                            :: currentTetrahedron
    type(triangle)                               :: intersectedTriangle
    
    ! Initialise dist to INF, retrieve the tetrahedron currently occupied 
    ! by the particle and compute potential triangle intersections.
    d = INF
    currentTetrahedron = self % tetrahedra % shelf(coords % elementIdx)
    rEnd = coords % rEnd
    call currentTetrahedron % computePotentialTriangles(rEnd, self % triangles, potentialTriangles)
    
    ! If no potential intersections are detected return early.
    if (size(potentialTriangles) == 0) return
    
    ! If reached here, compute which triangle is actually intersected and update d.
    r = coords % r
    call currentTetrahedron % computeIntersectedTriangle(r, rEnd, potentialTriangles, &
                                                         intersectedTriangleIdx, lambda, &
                                                         self % triangles)
    d = norm2(min(ONE, max(ZERO, lambda)) * (rEnd - r))
    
    ! If the intersected triangle is a boundary triangle then the particle is leaving the mesh.
    intersectedTriangle = self % triangles % shelf(intersectedTriangleIdx)
    if (intersectedTriangle % getIsBoundary()) then
      coords % elementIdx = 0
      coords % localId = 1
      return

    end if

    ! Else, retrieve the tetrahedra sharing the intersected triangle from mesh connectivity then
    ! update tetrahedronIdx and localId (if necessary).
    triangleToTetrahedra = intersectedTriangle % getTetrahedra()
    coords % elementIdx = findDifferent(triangleToTetrahedra, currentTetrahedron % getIdx())
    oldElement = currentTetrahedron % getElement()
    newElement = self % tetrahedra % shelf(coords % elementIdx) % getElement()
    if (newElement /= oldElement) coords % localId = self % cellZones % findCellZone(newElement)

  end subroutine distanceToNextFace

  !! Subroutine 'findElementAndParentIdxs'
  !!
  !! Basic description:
  !!   Returns the indices of the tetrahedron and parent element occupied by a particle.
  !!
  !! See mesh_inter for details.
  !!
  pure subroutine findElementAndParentIdxs(self, r, u, elementIdx, parentIdx)
    class(triUnstructuredMesh), intent(in)       :: self
    real(defReal), dimension(3), intent(in)      :: r, u
    integer(shortInt), intent(out)               :: elementIdx, parentIdx
    integer(shortInt)                            :: failedTriangle, i, nearestVertexIdx
    integer(shortInt), dimension(:), allocatable :: potentialTetrahedra, triangleToTetrahedra, &
                                                    zeroDotProductTriangles
    real(defReal), dimension(6)                  :: boundingBox
    type(tetrahedron)                            :: currentTetrahedron
    
    ! Initialise tetrahedronIdx = 0, retrieve the mesh's bounding box and check that the particle is 
    ! inside the mesh's bounding box. If not we can return early.
    elementIdx = 0
    parentIdx = 0
    boundingBox = self % getBoundingBox()
    do i = 1, 3
      if (r(i) < boundingBox(i) .or. boundingBox(i + 3) < r(i)) return

    end do

    ! If the point is inside the bounding box then we need to determine if the point is inside a
    ! pseudoCell. First find the vertex which is nearest to the coordinates.
    nearestVertexIdx = self % tree % findNearestVertex(r)
    
    ! Retrieve potential tetrahedra occupied by the particle from mesh connectivity information.
    potentialTetrahedra = self % vertices % shelf(nearestVertexIdx) % getVertexToTetrahedra()
    
    ! Initialise the search to the first element in the potential tetrahedra.
    currentTetrahedron = self % tetrahedra % shelf(potentialTetrahedra(1))
    searchLoop: do
      ! Check if the particle is inside the current tetrahedron.
      call currentTetrahedron % testForInclusion(self % triangles, r, failedTriangle, &
                                                 zeroDotProductTriangles)
      ! If the current tetrahedron is not occupied by the particle, retrieve the tetrahedron sharing
      ! the triangle for which the search failed and update the search.
      if (failedTriangle > 0) then
        triangleToTetrahedra = self % triangles % shelf(failedTriangle) % getTetrahedra()

        ! If the failed triangle is a boundary triangle the particle is outside the mesh.
        if (size(triangleToTetrahedra) == 1) return
        
        ! Update the tetrahedron to be searched and cycle.
        elementIdx = findDifferent(triangleToTetrahedra, currentTetrahedron % getIdx())
        currentTetrahedron = self % tetrahedra % shelf(elementIdx)
        cycle searchLoop

      end if
      
      ! If there are faces on which the particle lies we need to employ some more specific
      ! procedures to correctly determine which tetrahedron is actually occupied.
      if (allocated(zeroDotProductTriangles)) then
        select case (size(zeroDotProductTriangles))
          ! Particle is on a tetrahedron's face.
          case(1)
            elementIdx = self % findTetrahedronFromFace(u, currentTetrahedron % getIdx(), &
                                                        zeroDotProductTriangles)
          ! Particle is on a tetrahedron's edge.
          case(2)
            elementIdx = self % findTetrahedronFromEdge(u, zeroDotProductTriangles)
          ! Particle is on a tetrahedron's vertex.
          case(3)
            elementIdx = self % findTetrahedronFromVertex(u, zeroDotProductTriangles)  

        end select
        if (elementIdx > 0) parentIdx = self % tetrahedra % shelf(elementIdx) % getElement()
        return
      
      end if
      ! If reached this point the particle is in the current tetrahedron. Retrieve its index and 
      ! return.
      elementIdx = currentTetrahedron % getIdx()
      parentIdx = self % tetrahedra % shelf(elementIdx) % getElement()
      return

    end do searchLoop

  end subroutine findElementAndParentIdxs

  !! Function 'findTetrahedronFromEdge'
  !!
  !! Basic description:
  !!   Returns the index of the tetrahedron occupied by the particle in case the particle lies on
  !!   a tetrahedron edge.
  !!
  !! Detailed description:
  !!   Generalisation of 'findTetrahedronFromFace' applied to an edge. In this case the tetrahedron
  !!   assigned to the particle is that for which the number of negative dot products between the
  !!   tetrahedron's triangles containing the edge and the particle's direction is the greatest.
  !!
  !! Arguments:
  !!   u [in]                       -> Particle's direction.
  !!   zeroDotProductTriangles [in] -> Indices of the triangles on which the particle lies.
  !!
  !! Result:
  !!   tetrahedronIdx -> Index of the tetrahedron occupied by the particle.
  !!
  !! Notes:
  !!   The implementation here is quite ugly and messy. This is because OpenFOAM does not store
  !!   information about edges, so at the moment they have to be constructed on-the-fly. Could be
  !!   made more elegant / faster if there was a procedure to build edges during the importation 
  !!   process, but given how unlikely a particle is to actually sit on an edge, I am not sure this 
  !!   would make much difference...
  !!
  !! TODO: Rework this. Import edges during mesh construction.
  pure function findTetrahedronFromEdge(self, u, zeroDotProductTriangles) result(tetrahedronIdx)
    class(triUnstructuredMesh), intent(in)                   :: self
    real(defReal), dimension(3), intent(in)                  :: u
    integer(shortInt), dimension(:), allocatable, intent(in) :: zeroDotProductTriangles
    integer(shortInt)                                        :: i, j, tetrahedronIdx, count, maxCount, maxIdx
    integer(shortInt), dimension(:), allocatable             :: testTriangleIdxs, edgeVertices, &
                                                                potentialTetrahedra, absTriangleIdxs, triangleIdxs
    type(tetrahedron)                                        :: currentTetrahedron
    type(triangle)                                           :: currentTriangle
    real(defReal), dimension(3)                              :: normal
    
    ! Initialise tetrahedronIdx = 0 and retrieve the vertices in the common edge.
    tetrahedronIdx = 0
    testTriangleIdxs = abs(zeroDotProductTriangles)
    edgeVertices = findCommon(self % triangles % shelf(testTriangleIdxs(1)) % getVertices(), &
                              self % triangles % shelf(testTriangleIdxs(2)) % getVertices())
    
    ! Loop through all triangles.
    do i = 1, size(self % triangles % shelf)
      ! If the index of the 'do' loop corresponds to one of the triangles sharing the common edge
      ! there is no need to search and we cycle.
      if (any(testTriangleIdxs == i)) cycle
      
      ! Check if the current triangle contains the common edge and if so append the index to testFaceIdxs.
      if (size(findCommon(self % triangles % shelf(i) % getVertices(), edgeVertices)) == 2) call append(testTriangleIdxs, i)

    end do
    
    ! Loop through all the triangles that contain the common edge and retrieve their associated
    ! tetrahedra. We might introduce duplicates in the list of potential tetrahedra so remove them.
    do i = 1, size(testTriangleIdxs)
      currentTriangle = self % triangles % shelf(testTriangleIdxs(i))
      call append(potentialTetrahedra, currentTriangle % getTetrahedra()) 

    end do
    potentialTetrahedra = removeDuplicates(potentialTetrahedra)
    
    ! Initialise maxCount = 0 then loop through all potential tetrahedra.
    maxCount = 0
    do i = 1, size(potentialTetrahedra)
      ! Retrieve the triangles making the current tetrahedron and convert them to absolute indices.
      currentTetrahedron = self % tetrahedra % shelf(potentialTetrahedra(i))
      triangleIdxs = currentTetrahedron % getTriangles()
      absTriangleIdxs = abs(triangleIdxs)
      
      ! Initialise count = 0 then loop through all the triangles in the current tetrahedron.
      count = 0
      do j = 1, 4

        ! If the current triangle does not contain the common edge cycle to the next triangle.
        if (.not. any(testTriangleIdxs == absTriangleIdxs(j))) cycle

        ! Retrieve the current triangle's signed normal vector.
        currentTriangle = self % triangles % shelf(absTriangleIdxs(j))
        normal = currentTriangle % getNormal(triangleIdxs(j))
        
        ! If the dot product is negative increment count and cycle to the next triangle.
        if (dot_product(u, normal) <= ZERO) then
          count = count + 1
          cycle

        end if

        ! If the test fails and the current triangle is a boundary triangle, the particle is outside the mesh
        ! and we can return early.
        if (currentTriangle % getIsBoundary()) return

      end do

      ! If count > maxCount, update maxCount and maxIdx.
      if (count > maxCount) then
        maxCount = count
        maxIdx = i

      end if

    end do

    ! If reached here, update tetrahedronIdx.
    tetrahedronIdx = potentialTetrahedra(maxIdx)

  end function findTetrahedronFromEdge

  !! Function 'findTetrahedronFromFace'
  !!
  !! Basic description:
  !!   Returns the index of the tetrahedron occupied by the particle in case the particle lies on
  !!   a tetrahedron face.
  !!
  !! Detailed description:
  !!   When a particle is on a tetrahedron face it is not as straightforward to assign a tetrahedron
  !!   to a particle (it is actually in both tetrahedra at the same time). The workaround here is to
  !!   use the particle's direction to determine into which tetrahedron the particle's direction 
  !!   points. This is given by the dot product of the direction and the triangle's normal being
  !!   negative.
  !!
  !! Arguments:
  !!   u [in]                       -> Particle's direction.
  !!   zeroDotProductTriangles [in] -> Indices of the triangles on which the particle lies.
  !!
  !! Result:
  !!   tetrahedronIdx -> Index of the tetrahedron occupied by the particle.
  !!
  pure function findTetrahedronFromFace(self, u, currentTetrahedronIdx, &
                                        zeroDotProductTriangles) result(tetrahedronIdx)
    class(triUnstructuredMesh), intent(in)                   :: self
    real(defReal), dimension(3), intent(in)                  :: u
    integer(shortInt), intent(in)                            :: currentTetrahedronIdx
    integer(shortInt), dimension(:), allocatable, intent(in) :: zeroDotProductTriangles
    integer(shortInt)                                        :: absZeroDotProductTriangle, &
                                                                tetrahedronIdx
    integer(shortInt), dimension(:), allocatable             :: triangleToTetrahedra
    real(defReal), dimension(3)                              :: normal
    
    ! Initialise tetrahedronIdx = currentTetrahedronIdx then retrieve the triangle's signed normal vector.
    tetrahedronIdx = currentTetrahedronIdx
    absZeroDotProductTriangle = abs(zeroDotProductTriangles(1))
    normal = self % triangles % shelf(absZeroDotProductTriangle) % getNormal(zeroDotProductTriangles(1))
    
    ! Check the sign of the dot product between the particle's direction and the triangle's normal.
    ! If negative it is in the current tetrahedron and we can return early.
    if (dot_product(u, normal) <= ZERO) return

    ! If not, the particle's in the neighbouring tetrahedron. Retrieve mesh connectivity information.
    triangleToTetrahedra = self % triangles % shelf(absZeroDotProductTriangle) % getTetrahedra()

    ! If the current triangle is not a boundary triangle, update tetrahedronIdx.
    tetrahedronIdx = 0
    if (size(triangleToTetrahedra) > 1) tetrahedronIdx = findDifferent(triangleToTetrahedra, currentTetrahedronIdx)

  end function findTetrahedronFromFace

  !! Function 'findTetrahedronFromVertex'
  !!
  !! Basic description:
  !!   Returns the index of the tetrahedron occupied by the particle in case the particle lies on
  !!   a tetrahedron vertex.
  !!
  !! Detailed description:
  !!   Generalisation of 'findTetrahedronFromFace' applied to a vertex. In this case the tetrahedron
  !!   assigned to the particle is that for which the number of negative dot products between the
  !!   tetrahedron's triangles containing the vertex and the particle's direction is the greatest.
  !!
  !! Arguments:
  !!   direction [in]               -> Particle's direction.
  !!   zeroDotProductTriangles [in] -> Indices of the triangles on which the particle lies.
  !!
  !! Result:
  !!   tetrahedronIdx -> Index of the tetrahedron occupied by the particle.
  !!
  pure function findTetrahedronFromVertex(self, u, zeroDotProductTriangles) result(tetrahedronIdx)
    class(triUnstructuredMesh), intent(in)                   :: self
    real(defReal), dimension(3), intent(in)                  :: u
    integer(shortInt), dimension(:), allocatable, intent(in) :: zeroDotProductTriangles
    integer(shortInt)                                        :: commonVertex, i, j, tetrahedronIdx, count, &
                                                                maxCount, maxIdx
    integer(shortInt), dimension(:), allocatable             :: absTrianglesIdxs, &
                                                                absZeroDotProductTriangles, commonVertices, &
                                                                potentialTetrahedra, trianglesIdxs
    type(triangle)                                           :: currentTriangle
    real(defReal), dimension(3)                              :: normal
    
    ! Initialise tetrahedronIdx = 0. Find the common vertex between the triangles and retrieve all 
    ! tetrahedra sharing this vertex.
    tetrahedronIdx = 0
    absZeroDotProductTriangles = abs(zeroDotProductTriangles)
    commonVertices = self % triangles % shelf(absZeroDotProductTriangles(1)) % getVertices()
    do i = 2, size(absZeroDotProductTriangles)
      commonVertices = findCommon(commonVertices, self % triangles % shelf(absZeroDotProductTriangles(i)) % getVertices())

    end do
    commonVertex = commonVertices(1)
    potentialTetrahedra = self % vertices % shelf(commonVertex) % getVertexToTetrahedra()
    
    ! Initialise maxCount = 0 then loop through all potential tetrahedra.
    maxCount = 0
    do i = 1, size(potentialTetrahedra)
      ! Retrieve the triangles in the current tetrahedron and create absolute indices.
      trianglesIdxs = self % tetrahedra % shelf(potentialTetrahedra(i)) % getTriangles()
      absTrianglesIdxs = abs(trianglesIdxs)
      
      ! Initialise count = 0 then loop through all triangles.
      count = 0
      do j = 1, 4
        currentTriangle = self % triangles % shelf(absTrianglesIdxs(j))
        ! Cycle if the current triangle does not contain the common vertex.
        if (.not. any(currentTriangle % getVertices() == commonVertex)) cycle
        
        ! Retrieve the current triangle's normal vector and flip it if necessary.
        normal = currentTriangle % getNormal(trianglesIdxs(j))
        
        ! If the dot product is negative increment the number of triangles for the current 
        ! tetrahedron and cycle to the next triangle.
        if (dot_product(u, normal) <= ZERO) then
          count = count + 1
          cycle
  
        end if
        
        ! If the test fails and the current triangle is a boundary triangle, the particle is
        ! outside the mesh and we can return early.
        if (currentTriangle % getIsBoundary()) return

      end do

      ! If count > maxCount, update maxCount and maxIdx.
      if (count > maxCount) then
        maxCount = count
        maxIdx = i

      end if

    end do

    ! If reached here, update tetrahedronIdx.
    tetrahedronIdx = potentialTetrahedra(maxIdx)

  end function findTetrahedronFromVertex

  !! Subroutine 'kill'
  !!
  !! Basic description:
  !!   Returns to an unitialised state.
  !!
  elemental subroutine kill(self)
    class(triUnstructuredMesh), intent(inout) :: self

    ! Unstructured mesh.
    call kill_super(self)

    ! Local.
    call self % pyramids % kill()
    call self % tetrahedra % kill()
    call self % triangles % kill()

  end subroutine kill

  !! Subroutine 'replaceVertexShelf'
  !!
  !! Basic description:
  !!   Replaces the current vertexShelf of the mesh with a new shelf containing more vertices.
  !!   The new number of vertices is equal to the number of base mesh vertices plus the number
  !!   of mesh elements (since the elements are split from their centroids).
  !!
  elemental subroutine replaceVertexShelf(self)
    class(triUnstructuredMesh), intent(inout) :: self
    type(vertex), dimension(self % nVertices) :: shelf

    ! Allocate memory in the new shelf then copy elements from the original shelf.
    shelf = self % vertices % shelf
    if(allocated(self % vertices % shelf)) deallocate(self % vertices % shelf)
    allocate(self % vertices % shelf(self % nVertices + self % nElements))
    self % vertices % shelf(1:self % nVertices) = shelf

  end subroutine replaceVertexShelf

  !! Subroutine 'split'
  !!
  !! Basic description:
  !!   Splits a mesh into tetrahedral elements. If a given element is already a tetrahedron it is
  !!   not split but simply added to the shelf of tetrahedra in the mesh.
  !!
  !! Detailed description:
  !!   'split' starts by computing the number of pyramids, tetrahedra and triangles that will be
  !!   generated in the resulting mesh. Then, each element is split into a set of pyramids, whose
  !!   bases are each of the element's face and whose (common) apex is the element's centroid. This
  !!   apex is also appended to the list of vertices in the mesh in the process. Once this is done,
  !!   each face in the original mesh is subdivided into triangles. Lastly, each pyramid previously
  !!   created is further split into tetrahedra.
  !!
  !! Arguments:
  !!   lastVertexIdx [out] -> Index of the last vertex in the resulting mesh.
  !!
  elemental subroutine split(self, lastVertexIdx)
    class(triUnstructuredMesh), intent(inout) :: self
    integer(shortInt), intent(out)            :: lastVertexIdx
    integer(shortInt)                         :: nTriangles, nPyramids, nTetrahedra, lastTriangleIdx, &
                                                 lastTetrahedronIdx, lastPyramidIdx
    
    ! Compute the number of pyramids, triangles and tetrahedra to be created and
    ! allocate memory to the corresponding structures.
    call self % computePrimitives(nPyramids, nTriangles, nTetrahedra)
    allocate(self % pyramids % shelf(nPyramids))
    allocate(self % triangles % shelf(nTriangles))
    allocate(self % tetrahedra % shelf(nTetrahedra))
    
    ! Initialise lastVertexIdx, lastPyramidIdx, lastTetrahedronIdx and lastTriangleIdx then
    ! split all elements into pyramids and all pyramids into tetrahedra.
    lastVertexIdx = self % nVertices
    lastPyramidIdx = 0
    lastTetrahedronIdx = 0
    lastTriangleIdx = 0
    call self % splitElements(lastVertexIdx, lastPyramidIdx, lastTetrahedronIdx, lastTriangleIdx)
    call self % splitPyramids(lastTetrahedronIdx, lastTriangleIdx)

  end subroutine split

  !! Subroutine 'splitElements'
  !!
  !! Basic description:
  !!   Splits all elements in the original mesh into pyramids. If a given element is already a
  !!   tetrahedron it is not split but simply appended to the list of existing tetrahedra.
  !!
  !! Arguments:
  !!   lastVertexIdx [inout]      -> Index of the last vertex in the mesh.
  !!   lastPyramidIdx [inout]     -> Index of the last pyramid in the mesh.
  !!   lastTetrahedronIdx [inout] -> Index of the last tetrahedron in the mesh.
  !!   lastTriangleIdx [inout]    -> Index of the last triangle in the mesh.
  !!
  elemental subroutine splitElements(self, lastVertexIdx, lastPyramidIdx, lastTetrahedronIdx, lastTriangleIdx)
    class(triUnstructuredMesh), intent(inout)    :: self
    integer(shortInt), intent(inout)             :: lastVertexIdx, lastPyramidIdx, lastTetrahedronIdx, lastTriangleIdx
    integer(shortInt)                            :: i, j, initialTriangleIdx
    integer(shortInt), dimension(:), allocatable :: faces, vertices, triangles
    real(defReal), dimension(3)                  :: centroid
                                        
    ! Loop through all elements.
    do i = 1, self % nElements
      ! Retrieve the indices of the vertices and the faces in the current element as well as the centroid
      ! of the element.
      vertices = self % elements % shelf(i) % getVertices()
      faces = self % elements % shelf(i) % getFaces()
      centroid = self % elements % shelf(i) % getCentroid()

      ! If the current element is not a tetrahedron we need to split it. Update lastVertexIdx and add
      ! the current element's centroid to the shelf.
      if (size(vertices) > 4) then
        lastVertexIdx = lastVertexIdx + 1
        call self % vertices % shelf(lastVertexIdx) % setIdx(lastVertexIdx)
        call self % vertices % shelf(lastVertexIdx) % setCoordinates(centroid)
        
        ! Set initialTriangleIdx, split the current element into pyramids and cycle to the next element.
        initialTriangleIdx = lastTriangleIdx + 1
        call self % elements % shelf(i) % split(self % faces, self % vertices, self % triangles, &
                                                self % pyramids, lastTriangleIdx, lastPyramidIdx, &
                                                lastVertexIdx)
        cycle

      end if
      
      ! If the current element is already a tetrahedron then there is no need to split it: simply
      ! create a new tetrahedron in the shelf.
      lastTetrahedronIdx = lastTetrahedronIdx + 1
      call self % tetrahedra % shelf(lastTetrahedronIdx) % setIdx(lastTetrahedronIdx)
      call self % tetrahedra % shelf(lastTetrahedronIdx) % setVertices(vertices)
      call self % tetrahedra % shelf(lastTetrahedronIdx) % setElement(i)
      call self % tetrahedra % shelf(lastTetrahedronIdx) % setCentroid(centroid)
      
      ! Loop through all the faces of the new tetrahedron.
      do j = 1, 4
        ! Add the tetrahedron to the vertex.
        call self % vertices % shelf(vertices(j)) % addTetrahedronIdx(lastTetrahedronIdx)
        
        ! If faces(j) > 0 then the tetrahedron owns the current face and we need to add a 
        ! new triangle corresponding to this face to the shelf.
        if (faces(j) > 0) then
          ! Generate a new triangle from the current face and update mesh connectivity information.
          call self % faces % shelf(faces(j)) % split(self % triangles, self % vertices, lastTriangleIdx)
          call self % triangles % shelf(lastTriangleIdx) % addTetrahedronIdx(lastTetrahedronIdx)
          call self % tetrahedra % shelf(lastTetrahedronIdx) % addTriangle(lastTriangleIdx)
          cycle

        end if

        ! If faces(j) < 0 then a new triangle has already been generated for the current face. 
        ! Retrieve the triangle corresponding to the face and set mesh connectivity information.
        triangles = self % faces % shelf(abs(faces(j))) % getTriangles()
        call self % tetrahedra % shelf(lastTetrahedronIdx) % addTriangle(-triangles(1))
        call self % triangles % shelf(triangles(1)) % addTetrahedronIdx(lastTetrahedronIdx)

      end do
      
    end do

  end subroutine splitElements

  !! Subroutine 'splitPyramids'
  !!
  !! Basic description:
  !!   Splits all pyramids created during the splitting of original elements into tetrahedra. Also
  !!   splits the base of the pyramid into triangles if the pyramid owns the base.
  !!
  !! Arguments:
  !!   lastTetrahedronIdx [inout] -> Index of the last tetrahedron in the mesh.
  !!   lastTriangleIdx [inout]    -> Index of the last triangle in the mesh.
  !!
  elemental subroutine splitPyramids(self, lastTetrahedronIdx, lastTriangleIdx)
    class(triUnstructuredMesh), intent(inout)    :: self
    integer(shortInt), intent(inout)             :: lastTetrahedronIdx, lastTriangleIdx
    integer(shortInt)                            :: i, j, faceIdx, initialTriangleIdx, &
                                                    initialTetrahedronIdx
    integer(shortInt), dimension(:), allocatable :: triangles
    
    ! Loop over all the pyramids.
    do i = 1, size(self % pyramids % shelf)
      ! Retrieve the face making the pyramid's base.
      faceIdx = self % pyramids % shelf(i) % getFace()
      
      ! If the pyramid owns the face, split it into triangles.
      if (faceIdx > 0) then
        ! Set initialTriangleIdx and split the face.
        initialTriangleIdx = lastTriangleIdx + 1
        call self % faces % shelf(faceIdx) % split(self % triangles, self % vertices, lastTriangleIdx)

        ! Add all new triangles to the current pyramid.
        do j = initialTriangleIdx, lastTriangleIdx
          call self % pyramids % shelf(i) % addTriangle(j)

        end do

      else
        ! If the pyramid does not own the face then it has already been subdivided. Retrieve the 
        ! triangles in the current face and add each triangle to the pyramid.
        triangles = self % faces % shelf(abs(faceIdx)) % getTriangles()
        do j = 1, size(triangles)
          call self % pyramids % shelf(i) % addTriangle(-triangles(j))

        end do

      end if

      ! Update initialTriangleIdx and initialTetrahedronIdx then split the pyramid into tetrahedra.
      initialTriangleIdx = lastTriangleIdx + 1
      initialTetrahedronIdx = lastTetrahedronIdx + 1
      call self % pyramids % shelf(i) % split(self % faces % shelf(abs(faceIdx)), self % vertices, &
                                              self % triangles, self % tetrahedra, &
                                              lastTriangleIdx, lastTetrahedronIdx)

    end do

  end subroutine splitPyramids

end module triUnstructuredMesh_inter