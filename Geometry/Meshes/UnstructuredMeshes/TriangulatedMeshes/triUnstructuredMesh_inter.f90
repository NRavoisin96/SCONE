module triUnstructuredMesh_inter

  use numPrecision
  use universalVariables,     only : INF
  use genericProcedures,      only : append, findCommon, findDifferent, hasDuplicates, removeDuplicates
  use coord_class,            only : coord
  use dictionary_class,       only : dictionary
  use edge_class,             only : edge
  use pyramidShelf_class,     only : pyramidShelf
  use tetrahedron_class,      only : tetrahedron
  use tetrahedronShelf_class, only : tetrahedronShelf
  use triangle_class,         only : triangle
  use triangleShelf_class,    only : triangleShelf
  use unstructuredMesh_inter, only : unstructuredMesh, kill_super => kill
  use vertex_class,           only : vertex

  implicit none
  private

  ! Extendable procedures.
  public :: distanceToBoundaryFace, distanceToNextFace, findElementAndParentIdxs, kill

  !! Abstract interface to group all triangulated unstructured meshes. A triangulated unstructured mesh is an
  !! unstructured mesh whose faces have been decomposed into triangles and elements into tetrahedra.
  !!
  !! Public members:
  !!   pyramids                  -> Shelf that stores pyramids (intermediate products of decomposition).
  !!   tetrahedra                -> Shelf that stores tetrahedra.
  !!   triangles                 -> Shelf that stores triangles.
  !!
  !! Interface:
  !!   computePrimitives         -> Computes the number of primitive elements (triangles, pyramids and tetrahedra)
  !!                                to be generated during decomposition process.
  !!   distanceToBoundaryFace    -> Checks if a particle enters the mesh and returns distance to entry 
  !!                                intersection.
  !!   distanceToNextFace        -> Returns the distance to the next mesh face.
  !!   findElementAndParentIdxs  -> Returns the index of the mesh element occupied by a particle. Also
  !!                                returns the index of the parent mesh element containing the occupied
  !!                                element.
  !!   kill                      -> Returns to an unitialised state.
  !!   replaceEdgeShelf          -> Replaces the current edgeShelf of the mesh with a new shelf containing more 
  !!                                edges.
  !!   replaceVertexShelf        -> Replaces the current vertexShelf of the mesh with a new shelf containing more 
  !!                                vertices.
  !!   split                     -> Splits the elements of the mesh into tetrahedra and the faces into triangles.
  !!   splitElements             -> Splits the elements of the mesh into pyramids.
  !!   splitPyramids             -> Splits the pyramids generated by splitElements into tetrahedra.
  !!
  type, public, abstract, extends(unstructuredMesh) :: triUnstructuredMesh
    private
    type(pyramidShelf), public                      :: pyramids
    type(tetrahedronShelf), public                  :: tetrahedra
    type(triangleShelf), public                     :: triangles
  contains
    procedure, non_overridable                      :: computePrimitives
    procedure                                       :: distanceToBoundaryFace
    procedure                                       :: distanceToNextFace
    procedure                                       :: findElementAndParentIdxs
    procedure                                       :: findElementFromDirection
    procedure                                       :: kill
    procedure, non_overridable                      :: replaceEdgeShelf
    procedure, non_overridable                      :: replaceVertexShelf
    procedure, non_overridable                      :: split
    procedure, non_overridable                      :: splitElements
    procedure, non_overridable                      :: splitPyramids
  end type triUnstructuredMesh

contains

  !! Subroutine 'computePrimitives'
  !!
  !! Basic description:
  !!   Computes the number of pyramids, triangles and tetrahedra to be created during the mesh
  !!   splitting process.
  !!
  !! Detailed description:
  !!   The number of pyramids is simply given by the sum of the number of faces in each element in
  !!   the original element. The number of triangles is more complex: each pyramid created during
  !!   the splitting process also creates a number of triangles equal to the number of edges (or
  !!   vertices) in the current face. However, since all these triangles are internal they are
  !!   always shared between two pyramids; therefore, the number of triangles to be generated during
  !!   the pyramid creation process is, for a given element, equal to the sum of the number of
  !!   vertices in each of the element's face divided by two. Triangles are also created during the
  !!   splitting of the original mesh's faces: for a given face, the number of triangles to be
  !!   created is simply equal to the number of vertices in the face less two. Lastly, during the
  !!   splitting of pyramids into tetrahedra, additional internal triangles are created, given by
  !!   the number of vertices in a given pyramid's base less three. The number of tetrahedra to be
  !!   generated simply is, for a given face, the number of triangles it is decomposed into.
  !!
  !! Arguments:
  !!   nEdges [out]      -> Number of edges to be generated.
  !!   nPyramids [out]   -> Number of pyramids to be generated.
  !!   nTriangles [out]  -> Number of triangles to be generated.
  !!   nTetrahedra [out] -> Number of tetrahedra to be generated.
  !!   nVertices [out]   -> Number of vertices to be generated.
  !!
  elemental subroutine computePrimitives(self, nEdges, nPyramids, nTriangles, nTetrahedra, nVertices)
    class(triUnstructuredMesh), intent(in)       :: self
    integer(shortInt), intent(out)               :: nEdges, nPyramids, nTriangles, nTetrahedra, nVertices
    integer(shortInt)                            :: i, j, nVerticesInElement, nFaces, nVerticesInFace, &
                                                    absFaceIdx
    integer(shortInt), dimension(:), allocatable :: faceIdxs

    ! Initialise nEdges = 0, nPyramids = 0, nTetrahedra = 0 and nTriangles = 0 and loop through all elements.
    nEdges = 0
    nPyramids = 0
    nTetrahedra = 0
    nTriangles = 0
    nVertices = 0
    do i = 1, self % nElements
      ! Retrieve the number of vertices and indices of the faces in the current element.
      nVerticesInElement = size(self % elements % shelf(i) % getVertices())
      faceIdxs = self % elements % shelf(i) % getFaces()
      
      ! Check if the current element is already a tetrahedron. If yes, increment nTetrahedra by 1
      ! and nTriangles by the number of triangles owned by the tetrahedron then cycle.
      if (nVerticesInElement == 4) then
        nTetrahedra = nTetrahedra + 1
        nTriangles = nTriangles + count(faceIdxs > 0)
        cycle
      
      end if

      ! If the current element is not a tetrahedron it will be split from its centroid so we need
      ! to add the current element's centroid to the list of vertices.
      nVertices = nVertices + 1

      ! Increment nEdges.
      nEdges = nEdges + nVerticesInElement

      ! Compute the number of faces in the current element.
      nFaces = size(faceIdxs)
      
      ! Since there is one pyramid per element face, increase nPyramids by nFaces.
      nPyramids = nPyramids + nFaces
      
      ! Initialise nVertices and loop through all faces.
      nVerticesInElement = 0
      do j = 1, nFaces
        absFaceIdx = abs(faceIdxs(j))
        ! Retrieve the number of vertices in the current face and increase the total 
        ! number of vertices by the number of vertices in the current face.
        nVerticesInFace = size(self % faces % shelf(absFaceIdx) % getVertices())
        nVerticesInElement = nVerticesInElement + nVerticesInFace
        
        ! Increase the number of triangles corresponding to new internal faces by nVerticesInFace - 3.
        nTriangles = nTriangles + nVerticesInFace - 3

        ! If the element owns the current face, increase the number of triangles by nVerticesInFace - 2.
        if (faceIdxs(j) > 0) then
          nEdges = nEdges + nVerticesInFace - 3
          nTriangles = nTriangles + nVerticesInFace - 2

        end if
        
        ! There will be as many tetrahedra as the number of triangles in each face, which is given
        ! by nVerticesInFace - 2.
        nTetrahedra = nTetrahedra + nVerticesInFace - 2
      
      end do
      
      ! The number of pyramids' faces is given by half the total number of vertices.
      nTriangles = nTriangles + nVerticesInElement / 2

    end do

  end subroutine computePrimitives

  !! Subroutine 'distanceToBoundaryFace'
  !!
  !! Basic description:
  !!   Returns the distance to the mesh boundary face intersected by a particle's path. Also returns the index
  !!   of the parent element containing the intersected boundary face.
  !!
  !! See mesh_inter for details.
  !!
  elemental subroutine distanceToBoundaryFace(self, d, coords, parentIdx)
    class(triUnstructuredMesh), intent(in)       :: self
    real(defReal), intent(out)                   :: d
    type(coord), intent(inout)                   :: coords
    integer(shortInt), intent(out)               :: parentIdx
    integer(shortInt)                            :: edgeIdx, vertexIdx
    integer(shortInt), dimension(:), allocatable :: testTriangleIdxs, tetrahedronIdxs

    ! Initialise parentIdx = 0, edgeIdx = 0 and vertexIdx = 0 then search the tree for the intersected boundary triangle.
    parentIdx = 0
    edgeIdx = 0
    vertexIdx = 0
    call self % tree % findIntersectedTriangle(self % vertices, self % triangles, d, coords, edgeIdx, vertexIdx)

    ! If edgeIdx > 0 or vertexIdx > 0 then the particle intersects a boundary face through and edge or a vertex. In this
    ! case assign element occupation from particle direction.
    if (edgeIdx > 0 .or. vertexIdx > 0) then
      if (edgeIdx > 0) then
        testTriangleIdxs = self % edges % shelf(edgeIdx) % getTriangleIdxs()
        tetrahedronIdxs = self % edges % shelf(edgeIdx) % getTetrahedronIdxs()

      elseif (vertexIdx > 0) then
        testTriangleIdxs = self % vertices % shelf(vertexIdx) % getVertexToTriangles()
        tetrahedronIdxs = self % vertices % shelf(vertexIdx) % getVertexToTetrahedra()

      end if
      coords % elementIdx = self % findElementFromDirection(coords % dir, tetrahedronIdxs, testTriangleIdxs)
      
      ! If the particle's elementIdx is 0 (e.g., particle enters the mesh via a boundary vertex but still points outside)
      ! then update d = INF and return.
      if (coords % elementIdx == 0) then
        d = INF
        return

      end if

    end if
    if (coords % elementIdx > 0) parentIdx = self % tetrahedra % shelf(coords % elementIdx) % getElement()

  end subroutine distanceToBoundaryFace

  !! Subroutine 'distanceToNextFace'
  !!
  !! Basic description:
  !!   Returns the distance to the next triangle intersected by the particle's path. Returns
  !!   INF if the particle does not intersect any triangle (i.e., if its path is entirely
  !!   contained in the tetrahedron the particle currently is). Algorithm adapted from Macpherson, 
  !!   et al. (2009). DOI: 10.1002/cnm.1128.
  !!
  !! See mesh_inter for details.
  !!
  !! TODO: Optimise this.
  elemental subroutine distanceToNextFace(self, d, coords)
    class(triUnstructuredMesh), intent(in)       :: self
    real(defReal), intent(out)                   :: d
    type(coord), intent(inout)                   :: coords
    real(defReal), dimension(3)                  :: r, rEnd
    integer(shortInt)                            :: intersectedTriangleIdx, oldElement, newElement
    integer(shortInt), dimension(:), allocatable :: potentialTriangles, triangleToTetrahedra
    real(defReal)                                :: lambda
    type(tetrahedron)                            :: currentTetrahedron
    type(triangle)                               :: intersectedTriangle
    
    ! Initialise dist to INF, retrieve the tetrahedron currently occupied 
    ! by the particle and compute potential triangle intersections.
    d = INF
    currentTetrahedron = self % tetrahedra % shelf(coords % elementIdx)
    rEnd = coords % rEnd
    call currentTetrahedron % computePotentialTriangles(rEnd, self % triangles, potentialTriangles)
    
    ! If no potential intersections are detected return early.
    if (size(potentialTriangles) == 0) return
    
    ! If reached here, compute which triangle is actually intersected and update d.
    r = coords % r
    call currentTetrahedron % computeIntersectedTriangle(r, rEnd, potentialTriangles, &
                                                         intersectedTriangleIdx, lambda, &
                                                         self % triangles)
    d = norm2(min(ONE, max(ZERO, lambda)) * (rEnd - r))
    
    ! If the intersected triangle is a boundary triangle then the particle is leaving the mesh.
    intersectedTriangle = self % triangles % shelf(intersectedTriangleIdx)
    if (intersectedTriangle % getIsBoundary()) then
      coords % elementIdx = 0
      coords % localId = 1
      return

    end if

    ! Else, retrieve the tetrahedra sharing the intersected triangle from mesh connectivity then
    ! update tetrahedronIdx and localId (if necessary).
    triangleToTetrahedra = intersectedTriangle % getTetrahedra()
    coords % elementIdx = findDifferent(triangleToTetrahedra, currentTetrahedron % getIdx())
    oldElement = currentTetrahedron % getElement()
    newElement = self % tetrahedra % shelf(coords % elementIdx) % getElement()
    if (newElement /= oldElement) coords % localId = self % cellZones % findCellZone(newElement)

  end subroutine distanceToNextFace

  !! Subroutine 'findElementAndParentIdxs'
  !!
  !! Basic description:
  !!   Returns the indices of the tetrahedron and parent element occupied by a particle.
  !!
  !! See mesh_inter for details.
  !!
  pure subroutine findElementAndParentIdxs(self, r, u, elementIdx, parentIdx)
    class(triUnstructuredMesh), intent(in)       :: self
    real(defReal), dimension(3), intent(in)      :: r, u
    integer(shortInt), intent(out)               :: elementIdx, parentIdx
    integer(shortInt)                            :: failedTriangle, i, nearestVertexIdx, commonEdgeIdx, &
                                                    commonVertexIdx, j
    integer(shortInt), dimension(:), allocatable :: potentialTetrahedra, triangleToTetrahedra, &
                                                    zeroDotProductTriangles, testTriangleIdxs, &
                                                    commonVertexIdxs
    real(defReal), dimension(6)                  :: boundingBox
    type(tetrahedron)                            :: currentTetrahedron
    integer(shortInt), dimension(4)              :: tetrahedronVertexIdxs
    
    ! Initialise tetrahedronIdx = 0, retrieve the mesh's bounding box and check that the particle is 
    ! inside the mesh's bounding box. If not we can return early.
    elementIdx = 0
    parentIdx = 0
    boundingBox = self % getBoundingBox()
    do i = 1, 3
      if (r(i) < boundingBox(i) .or. boundingBox(i + 3) < r(i)) return

    end do

    ! If the point is inside the bounding box then we need to determine if the point is inside a
    ! pseudoCell. First find the vertex which is nearest to the coordinates.
    nearestVertexIdx = self % tree % findNearestVertex(r)
    
    ! Retrieve potential tetrahedra occupied by the particle from mesh connectivity information.
    potentialTetrahedra = self % vertices % shelf(nearestVertexIdx) % getVertexToTetrahedra()
    
    ! Initialise the search to the first element in the potential tetrahedra.
    currentTetrahedron = self % tetrahedra % shelf(potentialTetrahedra(1))
    searchLoop: do
      ! Check if the particle is inside the current tetrahedron.
      call currentTetrahedron % testForInclusion(self % triangles, r, failedTriangle, &
                                                 zeroDotProductTriangles)
      ! If the current tetrahedron is not occupied by the particle, retrieve the tetrahedron sharing
      ! the triangle for which the search failed and update the search.
      if (failedTriangle > 0) then
        triangleToTetrahedra = self % triangles % shelf(failedTriangle) % getTetrahedra()

        ! If the failed triangle is a boundary triangle the particle is outside the mesh.
        if (size(triangleToTetrahedra) == 1) return
        
        ! Update the tetrahedron to be searched and cycle.
        elementIdx = findDifferent(triangleToTetrahedra, currentTetrahedron % getIdx())
        currentTetrahedron = self % tetrahedra % shelf(elementIdx)
        cycle searchLoop

      end if
      
      ! If there are faces on which the particle lies we need to employ some more specific
      ! procedures to correctly determine which tetrahedron is actually occupied.
      if (allocated(zeroDotProductTriangles)) then
        select case (size(zeroDotProductTriangles))
          ! Particle is on a tetrahedron's face.
          case(1)
            potentialTetrahedra = self % triangles % shelf(zeroDotProductTriangles(1)) % getTetrahedra()
            testTriangleIdxs = zeroDotProductTriangles
          ! Particle is on a tetrahedron's edge.
          case(2)
            commonEdgeIdx = self % triangles % findCommonEdgeIdx(zeroDotProductTriangles(1), zeroDotProductTriangles(2))
            potentialTetrahedra = self % edges % shelf(commonEdgeIdx) % getTetrahedronIdxs()
            testTriangleIdxs = self % edges % shelf(commonEdgeIdx) % getTriangleIdxs()
          ! Particle is on a tetrahedron's vertex.
          case default
            commonVertexIdxs = self % triangles % shelf(zeroDotProductTriangles(1)) % getVertices()
            do i = 2, size(zeroDotProductTriangles)
              commonVertexIdxs = findCommon(commonVertexIdxs, self % triangles % shelf(zeroDotProductTriangles(i)) % getVertices())
              
            end do
            potentialTetrahedra = self % vertices % shelf(commonVertexIdxs(1)) % getVertexToTetrahedra()
            testTriangleIdxs = self % vertices % shelf(commonVertexIdxs(1)) % getVertexToTriangles()

        end select
        elementIdx = self % findElementFromDirection(u, potentialTetrahedra, testTriangleIdxs)
        if (elementIdx > 0) parentIdx = self % tetrahedra % shelf(elementIdx) % getElement()
        return
      
      end if
      ! If reached this point the particle is in the current tetrahedron. Retrieve its index and 
      ! return.
      elementIdx = currentTetrahedron % getIdx()
      parentIdx = self % tetrahedra % shelf(elementIdx) % getElement()
      return

    end do searchLoop

  end subroutine findElementAndParentIdxs

  !! Function 'findElementFromDirection'
  !!
  !! Basic description:
  !!   Returns the index of the element occupied by a particle in case the particle lies on one or more
  !!   element face(s).
  !!
  !! Detailed description:
  !!   When the particle lies on one or more element face(s), it is technically in more than one element
  !!   at once. In this case element occupation can be assigned by using the particle's direction vector.
  !!   The idea is to take all the faces on which the particle lies and perform the dot product of the
  !!   particle's direction with each of the face's (signed) normal vector. The element actually occupied
  !!   by the partice is then that for which the number of negative dot products is the greatest.
  !!
  !! Arguments:
  !!   u [in]            -> Particle's direction.
  !!   elementIdxs [in]  -> Indices of the elements to be tested.
  !!   testFaceIdxs [in] -> Indices of the faces to be tested.
  !!
  !! Result:
  !!   elementIdx        -> Index of the element occupied by the particle.
  !!
  pure function findElementFromDirection(self, u, elementIdxs, testFaceIdxs) result(elementIdx)
    class(triUnstructuredMesh), intent(in)       :: self
    real(defReal), dimension(3), intent(in)      :: u
    integer(shortInt), dimension(:), intent(in)  :: elementIdxs, testFaceIdxs
    integer(shortInt)                            :: elementIdx, i, j, count, maxCount, maxIdx
    integer(shortInt), dimension(4)              :: triangleIdxs, absTriangleIdxs
    type(tetrahedron)                            :: currentTetrahedron
    type(triangle)                               :: currentTriangle
    real(defReal), dimension(3)                  :: normal

    ! Initialise elementIdx = 0 and maxCount = 0 then loop over all elements.
    elementIdx = 0
    maxCount = 0
    do i = 1, size(elementIdxs)
      ! Retrieve the faces making the current element and convert them to absolute indices.
      currentTetrahedron = self % tetrahedra % shelf(elementIdxs(i))
      triangleIdxs = currentTetrahedron % getTriangles()
      absTriangleIdxs = abs(triangleIdxs)
      
      ! Initialise count = 0 then loop through all faces in the current element.
      count = 0
      do j = 1, 4

        ! Cycle to the next face if it is not a face on which the particle is.
        if (.not. any(testFaceIdxs == absTriangleIdxs(j))) cycle

        ! Retrieve the current face's signed normal vector.
        currentTriangle = self % triangles % shelf(absTriangleIdxs(j))
        normal = currentTriangle % getNormal(triangleIdxs(j))

        ! If the dot product is negative increment count and cycle to the next face.
        if (dot_product(u, normal) <= ZERO) then
          count = count + 1
          cycle

        end if
        
        ! If the test fails and the current face is a boundary face, the particle is outside the mesh
        ! and we can return early.
        if (currentTriangle % getIsBoundary()) return

      end do

      ! If count > maxCount, update maxCount and maxIdx.
      if (count > maxCount) then
        maxCount = count
        maxIdx = i

      end if

    end do

    ! If reached here, update elementIdx.
    elementIdx = elementIdxs(maxIdx)

  end function findElementFromDirection

  !! Subroutine 'kill'
  !!
  !! Basic description:
  !!   Returns to an unitialised state.
  !!
  elemental subroutine kill(self)
    class(triUnstructuredMesh), intent(inout) :: self

    ! Unstructured mesh.
    call kill_super(self)

    ! Local.
    call self % pyramids % kill()
    call self % tetrahedra % kill()
    call self % triangles % kill()

  end subroutine kill

  !! Subroutine 'replaceEdgeShelf'
  !!
  !! Basic description:
  !!   Replaces the current edgeShelf of the mesh with a new shelf containing more edges.
  !!
  !! Arguments:
  !!   nAdditionalEdges [in] -> Number of additional edges to be included.
  !!
  elemental subroutine replaceEdgeShelf(self, nAdditionalEdges)
    class(triUnstructuredMesh), intent(inout) :: self
    integer(shortInt), intent(in)             :: nAdditionalEdges
    type(edge), dimension(self % nEdges)      :: shelf

    ! Allocate memory in the new shelf then copy elements from the original shelf.
    shelf = self % edges % shelf
    if (allocated(self % edges % shelf)) deallocate(self % edges % shelf)
    allocate(self % edges % shelf(self % nEdges + nAdditionalEdges))
    self % edges % shelf(1:self % nEdges) = shelf

  end subroutine replaceEdgeShelf

  !! Subroutine 'replaceVertexShelf'
  !!
  !! Basic description:
  !!   Replaces the current vertexShelf of the mesh with a new shelf containing more vertices.
  !!   The new number of vertices is equal to the number of base mesh vertices plus the number
  !!   of mesh elements (since the elements are split from their centroids).
  !!
  elemental subroutine replaceVertexShelf(self, nAdditionalVertices)
    class(triUnstructuredMesh), intent(inout) :: self
    integer(shortInt), intent(in)             :: nAdditionalVertices
    type(vertex), dimension(self % nVertices) :: shelf

    ! Allocate memory in the new shelf then copy elements from the original shelf.
    shelf = self % vertices % shelf
    if (allocated(self % vertices % shelf)) deallocate(self % vertices % shelf)
    allocate(self % vertices % shelf(self % nVertices + nAdditionalVertices))
    self % vertices % shelf(1:self % nVertices) = shelf

  end subroutine replaceVertexShelf

  !! Subroutine 'split'
  !!
  !! Basic description:
  !!   Splits a mesh into tetrahedral elements. If a given element is already a tetrahedron it is
  !!   not split but simply added to the shelf of tetrahedra in the mesh.
  !!
  !! Detailed description:
  !!   'split' starts by computing the number of pyramids, tetrahedra and triangles that will be
  !!   generated in the resulting mesh. Then, each element is split into a set of pyramids, whose
  !!   bases are each of the element's face and whose (common) apex is the element's centroid. This
  !!   apex is also appended to the list of vertices in the mesh in the process. Once this is done,
  !!   each face in the original mesh is subdivided into triangles. Lastly, each pyramid previously
  !!   created is further split into tetrahedra.
  !!
  !! Arguments:
  !!   lastVertexIdx [out] -> Index of the last vertex in the resulting mesh.
  !!
  subroutine split(self)
    class(triUnstructuredMesh), intent(inout) :: self
    integer(shortInt)                         :: nEdges, nTriangles, nPyramids, nTetrahedra, nVertices, &
                                                 lastEdgeIdx, lastTriangleIdx, lastTetrahedronIdx, &
                                                 lastPyramidIdx, lastVertexIdx
    
    ! Compute the number of edges, pyramids, triangles and tetrahedra to be created and
    ! allocate memory to the corresponding structures.
    call self % computePrimitives(nEdges, nPyramids, nTriangles, nTetrahedra, nVertices)
    allocate(self % pyramids % shelf(nPyramids))
    allocate(self % triangles % shelf(nTriangles))
    allocate(self % tetrahedra % shelf(nTetrahedra))
    call self % replaceEdgeShelf(nEdges)
    call self % replaceVertexShelf(nVertices)
    
    ! Initialise lastVertexIdx, lastPyramidIdx, lastTetrahedronIdx and lastTriangleIdx then
    ! split all elements into pyramids and all pyramids into tetrahedra.
    lastEdgeIdx = self % nEdges
    lastVertexIdx = self % nVertices
    lastPyramidIdx = 0
    lastTetrahedronIdx = 0
    lastTriangleIdx = 0
    call self % splitElements(lastEdgeIdx, lastPyramidIdx, lastTetrahedronIdx, lastTriangleIdx, lastVertexIdx)
    call self % splitPyramids(lastEdgeIdx, lastTetrahedronIdx, lastTriangleIdx)

    ! Update number of vertices and edges.
    self % nEdges = lastEdgeIdx
    self % nVertices = lastVertexIdx

  end subroutine split

  !! Subroutine 'splitElements'
  !!
  !! Basic description:
  !!   Splits all elements in the original mesh into pyramids. If a given element is already a
  !!   tetrahedron it is not split but simply appended to the list of existing tetrahedra.
  !!
  !! Arguments:
  !!   lastEdgeIdx [inout]        -> Index of the last edge in the mesh.
  !!   lastPyramidIdx [inout]     -> Index of the last pyramid in the mesh.
  !!   lastTetrahedronIdx [inout] -> Index of the last tetrahedron in the mesh.
  !!   lastTriangleIdx [inout]    -> Index of the last triangle in the mesh.
  !!   lastVertexIdx [inout]      -> Index of the last vertex in the mesh.
  !!
  subroutine splitElements(self, lastEdgeIdx, lastPyramidIdx, lastTetrahedronIdx, lastTriangleIdx, lastVertexIdx)
    class(triUnstructuredMesh), intent(inout)    :: self
    integer(shortInt), intent(inout)             :: lastEdgeIdx, lastPyramidIdx, lastTetrahedronIdx, lastTriangleIdx, lastVertexIdx
    integer(shortInt)                            :: i, j, k, edgeIdx, triangleIdx
    integer(shortInt), dimension(3)              :: edgeIdxs
    integer(shortInt), dimension(:), allocatable :: faces, vertices, triangles
    real(defReal), dimension(3)                  :: centroid
                                        
    ! Loop through all elements.
    do i = 1, self % nElements
      ! Retrieve the indices of the vertices and the faces in the current element as well as the centroid
      ! of the element.
      vertices = self % elements % shelf(i) % getVertices()
      faces = self % elements % shelf(i) % getFaces()
      centroid = self % elements % shelf(i) % getCentroid()

      ! If the current element is not a tetrahedron we need to split it. Update lastVertexIdx and add
      ! the current element's centroid to the shelf.
      if (size(vertices) > 4) then
        lastVertexIdx = lastVertexIdx + 1
        call self % vertices % shelf(lastVertexIdx) % setIdx(lastVertexIdx)
        call self % vertices % shelf(lastVertexIdx) % setCoordinates(centroid)
        
        ! Split the current element into pyramids and cycle to the next element.
        call self % elements % shelf(i) % split(self % faces, self % edges, self % vertices, self % triangles, self % pyramids, &
                                                lastEdgeIdx, lastTriangleIdx, lastPyramidIdx, lastVertexIdx)
        cycle

      end if
      
      ! If the current element is already a tetrahedron then there is no need to split it: simply
      ! create a new tetrahedron in the shelf.
      lastTetrahedronIdx = lastTetrahedronIdx + 1
      call self % tetrahedra % shelf(lastTetrahedronIdx) % setIdx(lastTetrahedronIdx)
      call self % tetrahedra % shelf(lastTetrahedronIdx) % setVertices(vertices)
      call self % tetrahedra % shelf(lastTetrahedronIdx) % setElement(i)
      call self % tetrahedra % shelf(lastTetrahedronIdx) % setCentroid(centroid)
      
      ! Loop through all the faces of the new tetrahedron.
      do j = 1, 4
        ! Add the tetrahedron to the vertex.
        call self % vertices % shelf(vertices(j)) % addTetrahedronIdx(lastTetrahedronIdx)
        
        ! If faces(j) > 0 then the tetrahedron owns the current face and we need to add a 
        ! new triangle corresponding to this face to the shelf.
        if (faces(j) > 0) then
          ! Generate a new triangle from the current face and update mesh connectivity information.
          call self % faces % shelf(faces(j)) % split(self % edges, self % triangles, self % vertices, lastEdgeIdx, lastTriangleIdx)
          triangleIdx = lastTriangleIdx
          call self % tetrahedra % shelf(lastTetrahedronIdx) % addTriangle(lastTriangleIdx)

        else
          ! If faces(j) < 0 then a new triangle has already been generated for the current face. 
          ! Retrieve the triangle corresponding to the face and set mesh connectivity information.
          triangles = self % faces % shelf(abs(faces(j))) % getTriangles()
          triangleIdx = triangles(1)
          call self % tetrahedra % shelf(lastTetrahedronIdx) % addTriangle(-triangleIdx)

        end if

        ! Set mesh connectivity information.
        call self % triangles % shelf(triangleIdx) % addTetrahedronIdx(lastTetrahedronIdx)
        edgeIdxs = self % triangles % shelf(triangleIdx) % getEdgeIdxs()
        do k = 1, 3
          edgeIdx = edgeIdxs(k)
          call self % edges % shelf(edgeIdx) % addTetrahedronIdx(lastTetrahedronIdx)
          call self % tetrahedra % shelf(lastTetrahedronIdx) % addEdgeIdx(edgeIdx)

        end do

      end do
      
    end do

  end subroutine splitElements

  !! Subroutine 'splitPyramids'
  !!
  !! Basic description:
  !!   Splits all pyramids created during the splitting of original elements into tetrahedra. Also
  !!   splits the base of the pyramid into triangles if the pyramid owns the base.
  !!
  !! Arguments:
  !!   lastTetrahedronIdx [inout] -> Index of the last tetrahedron in the mesh.
  !!   lastTriangleIdx [inout]    -> Index of the last triangle in the mesh.
  !!
  subroutine splitPyramids(self, lastEdgeIdx, lastTetrahedronIdx, lastTriangleIdx)
    class(triUnstructuredMesh), intent(inout)    :: self
    integer(shortInt), intent(inout)             :: lastEdgeIdx, lastTetrahedronIdx, lastTriangleIdx
    integer(shortInt)                            :: i, j, faceIdx, initialTriangleIdx
    integer(shortInt), dimension(:), allocatable :: triangles
    
    ! Loop over all the pyramids.
    do i = 1, size(self % pyramids % shelf)
      ! Retrieve the face making the pyramid's base.
      faceIdx = self % pyramids % shelf(i) % getFace()
      
      ! If the pyramid owns the face, split it into triangles.
      if (faceIdx > 0) then
        ! Set initialTriangleIdx and split the face.
        initialTriangleIdx = lastTriangleIdx + 1
        call self % faces % shelf(faceIdx) % split(self % edges, self % triangles, self % vertices, lastEdgeIdx, lastTriangleIdx)

        ! Add all new triangles to the current pyramid.
        do j = initialTriangleIdx, lastTriangleIdx
          call self % pyramids % shelf(i) % addTriangle(j)

        end do

      else
        ! If the pyramid does not own the face then it has already been subdivided. Retrieve the 
        ! triangles in the current face and add each triangle to the pyramid.
        triangles = self % faces % shelf(abs(faceIdx)) % getTriangles()
        do j = 1, size(triangles)
          call self % pyramids % shelf(i) % addTriangle(-triangles(j))

        end do

      end if

      ! Update initialTriangleIdx then split the pyramid into tetrahedra.
      initialTriangleIdx = lastTriangleIdx + 1
      call self % pyramids % shelf(i) % split(self % faces % shelf(abs(faceIdx)), self % edges, &
                                              self % vertices, self % triangles, self % tetrahedra, &
                                              lastTriangleIdx, lastTetrahedronIdx)

    end do

  end subroutine splitPyramids

end module triUnstructuredMesh_inter