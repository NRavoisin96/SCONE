module latUniverse_class

  use numPrecision
  use universalVariables, only : INF, SURF_TOL
  use genericProcedures,  only : fatalError, numToChar, swap
  use dictionary_class,   only : dictionary
  use coord_class,        only : coord
  use charMap_class,      only : charMap
  use surfaceShelf_class, only : surfaceShelf
  use box_class,          only : box
  use cell_inter,         only : cell
  use cellShelf_class,    only : cellShelf
  use meshShelf_class,    only : meshShelf
  use universe_inter,     only : universe, kill_super => kill, charToFill

  implicit none
  private

  ! Parameters
  ! Note X/Y/Z MIN/MAX MUST have the value they have (or generated by a function)
  integer(shortInt), parameter :: X_MIN = -1, X_MAX = -2, Y_MIN = -3, Y_MAX = -4, Z_MIN = -5, &
                                  Z_MAX = -6, OUTLINE_SURF = -7

  !!
  !! 2D or 3D Cartesian lattice with constant pitch
  !!
  !! Universe consists of a lattice of fixed, finite size (e.g 17x17x2). Centre of the
  !! lattice is placed at the origin. An additional cell is placed beyond the lattice
  !! called background (or out) cell.
  !!
  !! Local ID is 1 in bottom X, Y & Z corner. It increases first with X, then Y, then Z.
  !! Cells inside the lattice can only be filled with a universe (given as integer ID).
  !! Background cell can have any filling given by keyword (material or universe)
  !!
  !! Every lattice cell has an offset to its centre (so the centre of the nested universe
  !! is in the center of the lattice cell).
  !!
  !! Minimum lattice pitch is set to 10 * SURF_TOL
  !!
  !! Sample Input Dictionary (3D):
  !!   latt { id 7;
  !!          type latUniverse;
  !!          #origin (0.0 0.0 0.0); #
  !!          #rotation (30.0 0.0 0.0); #
  !!          shape (3 2 2);
  !!          pitch (1.0 1.0 1.0);
  !!          padMat <u13>;
  !!          map (  1  2  3    // Top layer
  !!                 4  5  6    // Lower Y row
  !!                 7  8  9    // Bottom layer
  !!                10 11 12  )
  !!   }
  !!
  !! Sample Input Dictionary (2D):
  !!   latt2D { id 8;
  !!            shape (2 2 0);       // 0 indicates infinite extent in z-axis
  !!            pitch (1.0 1.0 0.0); // Any pitch is allowed in z, use 0.0 for clarity
  !!            padMat void;
  !!            map ( 1 2
  !!                  2 1);
  !!   }
  !!
  !! NOTE: Input in MAP for a single layer is WYSIWYG. Lower row in map is lower row in
  !!   geometry. There is no inversion like in other (e.g. Serpent) MC codes. Basically
  !!   input vector is flipped in Y and Z direction.
  !!
  !! Private Members:
  !!  pitch      -> Values of lattice pitch in x, y & z directions
  !!  sizeN      -> Number of lattice cells in x, y & z directions
  !!  corner     -> Location of the minimum corner
  !!  a_bar      -> Halfwidth of lattice cell reduced by surface tolerance
  !!  outline    -> Box type surface that is a boundary between lattice & background
  !!  outLocalID -> LocalID of the background cell
  !!
  !! Interface:
  !!   universe interface
  !!
  type, public, extends(universe) :: latUniverse
    private
    real(defReal), dimension(3)     :: pitch = ZERO, corner = ZERO, a_bar = ZERO
    integer(shortInt), dimension(3) :: sizeN = 0
    type(box)                       :: outline
    integer(shortInt)               :: outLocalID = 0
  contains
    ! Superclass procedures
    procedure :: init
    procedure :: kill
    procedure :: findCell
    procedure :: distance
    procedure :: cross
    procedure :: cellOffset
  end type latUniverse

contains
  !!
  !! Initialise Universe
  !!
  !! See universe_inter for details.
  !!
  !! Errors:
  !!   fatalError if input is invalid.
  !!
  subroutine init(self, dict, mats, fills, cells, surfs, meshes)
    class(latUniverse), intent(inout)                         :: self
    class(dictionary), intent(in)                             :: dict
    type(charMap), intent(in)                                 :: mats
    integer(shortInt), dimension(:), allocatable, intent(out) :: fills
    type(cellShelf), intent(inout)                            :: cells
    type(surfaceShelf), intent(inout)                         :: surfs
    type(meshShelf), intent(inout)                            :: meshes
    real(defReal), dimension(:), allocatable                  :: temp
    integer(shortInt), dimension(:), allocatable              :: tempI
    integer(shortInt)                                         :: N, i, j, jPrime, outFill
    type(dictionary)                                          :: tempDict
    integer(shortInt), dimension(:,:), allocatable            :: tempMap
    character(nameLen)                                        :: name
    character(100), parameter                                 :: Here = 'init (latUniverse_class.f90)'

    ! Setup the base class
    ! With: id, origin rotations...
    call self % setupBase(dict)

    ! Load pitch.
    call dict % get(temp, 'pitch')
    N = size(temp)
    if (N /= 3) call fatalError(Here, 'Pitch must have size 3. Has: '//numToChar(N)//'.')
    self % pitch = temp

    ! Load shape.
    call dict % get(tempI, 'shape')
    N = size(tempI)
    if (N /= 3) call fatalError(Here, 'Shape must have size 3. Has: '//numToChar(N)//'.')
    if (any(tempI < 0)) call fatalError(Here, 'Shape cannot contain -ve entries.')
    self % sizeN = tempI

    ! Detect reduced Z dimension and adjust shape and pitch accordingly.
    if (self % sizeN(3) == 0) then
      self % sizeN(3) = 1
      self % pitch(3) = TWO * INF
    end if

    ! Check X & Y for 0 size.
    if (any(self % sizeN == 0)) call fatalError(Here, 'Shape in X and Y axis cannot be 0.')

    ! Check for invalid pitch.
    if (any(self % pitch < 10 * SURF_TOL)) call fatalError(Here, 'Pitch size must be larger than: '//numToChar(10 * SURF_TOL)//'.')

    ! Calculate reduced halfwidth and corner.
    self % a_bar = HALF * self % pitch - SURF_TOL
    self % corner = -HALF * self % sizeN * self % pitch

    ! Calculate local ID of the background cell.
    self % outLocalID = product(self % sizeN) + 1

    ! Build outline box
    call tempDict % init(4)
    call tempDict % store('type', 'box')
    call tempDict % store('id', 1)
    call tempDict % store('origin', [ZERO, ZERO, ZERO])
    call tempDict % store('halfwidth', abs(self % corner))
    call self % outline % init(tempDict)

    ! Construct fill array
    call dict % get(tempI, 'map')

    ! Flip array up-down for more natural input. Reshape into rank 2 array.
    tempMap = reshape(tempI, [self % sizeN(1), self % sizeN(2) * self % sizeN(3)])
    N = size(tempMap, 2)
    do i = 1, N / 2
      call swap(tempMap(:,i), tempMap(:,N - i + 1))

    end do

    ! Find background fill and change to tempMap to uniID.
    tempMap = -tempMap
    call dict % get(name, 'padMat')
    outFill = charToFill(name, mats, Here)

    ! Build fill array.
    allocate(fills(self % outLocalID))
    N = size(tempMap, 1)
    do j = 1, size(tempMap, 2)
      jPrime = (j - 1) * N
      do i = 1, N
        fills(i + jPrime) = tempMap(i, j)

      end do

    end do
    fills(self % outLocalID) = outFill

  end subroutine init

  !!
  !! Find local cell ID given a point
  !!
  !! See universe_inter for details.
  !!
  pure subroutine findCell(self, r, u, localId, cellIdx, elementIdx)
    class(latUniverse), intent(inout)       :: self
    real(defReal), dimension(3), intent(in) :: r, u
    integer(shortInt), intent(out)          :: localId, cellIdx, elementIdx
    integer(shortInt), dimension(3)         :: ijk
    integer(shortInt)                       :: i, inc
    real(defReal), dimension(3)             :: corner, pitch, r_bar
    real(defReal)                           :: r_barComponent, uComponent

    ! Initialise cellIdx = 0 and localId = self % outLocalID.
    cellIdx = 0
    elementIdx = 0
    localId = self % outLocalID

    ! Find lattice location in x, y & z and get position wrt middle of the lattice cell.
    corner = self % corner
    pitch = self % pitch
    ijk = floor((r - corner) / pitch) + 1
    r_bar = r - corner + pitch * (HALF - ijk)

    ! Check if particle is within surface tolerance. Push it to next cell if yes.
    do i = 1, 3
      r_barComponent = r_bar(i)
      uComponent = u(i)
      
      ! Cycle to next dimension if particle is well within current cell or enters it.
      if (abs(r_barComponent) <= self % a_bar(i) .or. r_barComponent * uComponent <= ZERO) cycle
      ijk(i) = ijk(i) + sign(1, floor(uComponent))

    end do

    ! If particle is outside lattice return early. Else update localId.
    if (any(ijk < 1 .or. ijk > self % sizeN)) return
    localId = ijk(1) + self % sizeN(1) * (ijk(2) - 1 + self % sizeN(2) * (ijk(3) - 1))

  end subroutine findCell

  !!
  !! Return distance to the next boundary between local cells in the universe
  !!
  !! See universe_inter for details.
  !!
  pure subroutine distance(self, coords, d, surfIdx)
    class(latUniverse), intent(inout)  :: self
    type(coord), intent(inout)         :: coords
    real(defReal), intent(out)         :: d
    integer(shortInt), intent(out)     :: surfIdx
    real(defReal), dimension(3)        :: pitch, r_bar, u, bounds
    real(defReal)                      :: test_d
    integer(shortInt)                  :: localId, i, axis

    ! Catch case if particle is outside the lattice and return early if yes.
    localId = coords % localId
    if (localId == self % outLocalID) then
      surfIdx = OUTLINE_SURF
      d = self % outline % distance(coords % r, coords % dir)
      return

    end if

    ! Find position wrt lattice cell centre. Need to use localID to properly handle under and overshoots.
    pitch = self % pitch
    r_bar = coords % r - (self % corner + (get_ijk(localId, self % sizeN) - HALF) * pitch)

    ! Select surfaces in the direction of the particle.
    u = coords % dir
    bounds = sign(HALF * pitch, u)

    ! Find minimum distance.
    ! Relies on IEEE 754 standard for NaN and Infinity.
    ! 0.0/0.0 = NaN and (NaN < A = false; for every A)
    ! A/0.0 = Infinity (if A > 0.0)
    !
    ! Provide default axis to ensure no out of bounds array access if
    ! all distances happen to be infinite.
    d = INF
    axis = 1
    do i = 1, 3
      ! Nominator and denominator will have the same sign (by earlier bounds selection)
      test_d = (bounds(i) - r_bar(i)) / u(i)

      if (test_d < d) then
        d = test_d
        axis = i

      end if

    end do

    ! Cap distance value and generate surface memento.
    d = min(INF, max(ZERO, d))
    surfIdx = axis * 2
    if (u(axis) < ZERO) surfIdx = surfIdx - 1
    surfIdx = -surfIdx

  end subroutine distance

  !!
  !! Cross between local cells
  !!
  !! See universe_inter for details.
  !!
  pure subroutine cross(self, coords, surfIdx)
    class(latUniverse), intent(inout) :: self
    type(coord), intent(inout)        :: coords
    integer(shortInt), intent(in)     :: surfIdx

    call self % findCell(coords % r, coords % dir, coords % localID, coords % cellIdx, coords % elementIdx)

  end subroutine cross

  !!
  !! Return offset for the current cell
  !!
  !! See universe_inter for details.
  !!
  pure function cellOffset(self, coords) result (offset)
    class(latUniverse), intent(in)  :: self
    type(coord), intent(in)         :: coords
    real(defReal), dimension(3)     :: offset
    integer(shortInt)               :: localId

    ! Retrieve localId and initialise offset = ZERO.
    localId = coords % localId
    offset = ZERO

    ! If particle is outside lattice return early. Else update offset.
    if (localId == self % outLocalID) return
    offset = (get_ijk(localId, self % sizeN) - HALF) * self % pitch + self % corner

  end function cellOffset

  !!
  !! Return to uninitialised state
  !!
  elemental subroutine kill(self)
    class(latUniverse), intent(inout) :: self

    ! Superclass
    call kill_super(self)

    ! Kill local
    self % pitch = ZERO
    self % sizeN = 0
    self % corner = ZERO
    self % a_bar  = ZERO
    call self % outline % kill()
    self % outLocalID = 0

  end subroutine kill

  !!
  !! Generate ijk from localID and shape
  !!
  !! Args:
  !!   localId [in] -> Local id of the cell between 1 and product(sizeN)
  !!   sizeN [in]   -> Number of cells in each cardinal direction x,y&z
  !!
  !! Result:
  !!   Array ijk which has integer position in each cardinal direction
  !!
  pure function get_ijk(localId, sizeN) result(ijk)
    integer(shortInt), intent(in)               :: localId
    integer(shortInt), dimension(3), intent(in) :: sizeN
    integer(shortInt), dimension(3)             :: ijk
    integer(shortInt)                           :: temp, base

    temp = localId - 1

    base = temp / sizeN(1)
    ijk(1) = temp - sizeN(1) * base + 1

    temp = base
    base = temp / sizeN(2)
    ijk(2) = temp - sizeN(2) * base + 1

    ijk(3) = base + 1

  end function get_ijk

end module latUniverse_class