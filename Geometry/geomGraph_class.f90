module geomGraph_class

  use numPrecision
  use genericProcedures, only : fatalError, numToChar, isIn, quickSort
  use dictionary_class,  only : dictionary
  use intMap_class,      only : intMap
  use uniFills_class,    only : uniFills

  implicit none
  private

  !!
  !! Information about a unique cell fill
  !!
  !! Public:
  !!   idx -> matIdx or -uniIdx of the filling of local cell (-ve entry indicates universe)
  !!   id  -> Unique ID if is material fill or uniRootID otherwise
  !!
  !! uniRootID is the location of the data for the given universe in array
  !!
  type, private :: location
    integer(shortInt) :: idx = 0
    integer(shortInt) :: id  = 0
  end type location

  !!
  !! Runtime representation of geometry nesting structure
  !!
  !! Is a directed acyclic graph represented by a 1D array. Each entry contains
  !! two numbers: idx which determines content (matIdx or -uniIdx); id which is
  !! a uniRootID (universe fill) or uniqueID (material fill).
  !!
  !! UniRootID is the location of the beginning of data for a given universe. Fill for different
  !! local cells has the location: uniRootID + localID - 1.
  !!
  !! Note that there is no checking for the validity of localIDs! If a number outside
  !! a valid localID for the universe is given, content will be read from a different universe!
  !!
  !! Unique IDs are generated by enumeration of the graph sinks (local cells with material fill).
  !!
  !! Sample Input Dictionary:
  !!   graph1 {type shrunk;}
  !!   graph2 {type extended;}
  !!
  !!
  !! Two types are available:
  !!   'shrunk'    -> Each local (material) cell has the same uniqueID in all universe instances
  !!   'extended'  -> Every local (material) cell has its own uniqueID in all universe instances
  !!
  !! Public Members:
  !!   array       -> Array with graph data
  !!   uniqueCells -> Number of uniqueCells in the structure
  !!   usedMats    -> Sorted list of matIdxs which are used in the geometry
  !!
  !! Interface:
  !!   init        -> Build from uniFills and dictionary definition
  !!   getFill     -> Get filling information at location given by uniRootID & localID
  !!   kill        -> Return to uninitialised state
  !!
  type, public :: geomGraph
    type(location), dimension(:), allocatable    :: array
    integer(shortInt)                            :: uniqueCells = 0
    integer(shortInt), dimension(:), allocatable :: usedMats

  contains
    procedure :: init
    procedure :: getFill
    procedure :: kill

    ! Private procedures
    procedure, private :: buildShrunk
    procedure, private :: buildExtended
    procedure, private :: setUniqueIds
  end type geomGraph

contains

  !!
  !! Initialise graph representation of the geometry structure
  !!
  !! Args:
  !!   fills [in] -> Universe fill information
  !!   dict [in]  -> Dictionary with settings
  !!
  !! Errors:
  !!   fatalError if type (unique generation strategy) is unknown
  !!
  !! Assumes that `fills` is valid:
  !!   * No cycles
  !!   * No invalid uni indexes in the structure
  !!
  subroutine init(self, fills, dict)
    class(geomGraph), intent(inout) :: self
    type(uniFills), intent(in)      :: fills
    class(dictionary), intent(in)   :: dict
    character(nameLen)              :: type
    character(100), parameter :: Here = 'init (geomGraph_class.f90)'

    ! Select specific build procedure
    call dict % get(type, 'type')

    select case(type)
      case ('shrunk')
        call self % buildShrunk(fills)

      case ('extended')
        call self % buildExtended(fills)

      case default
        print *, "AVAILABLE GEOMETRY GRAPH TYPES:"
        print *, 'shrunk'
        print *, 'extended'
        call fatalError(Here, 'Unknown geometry graph type (unique cell generation &
                        &strategy): '//trim(type))
    end select

  end subroutine init

  !!
  !! Return fill information for a local cell in a universe
  !!
  !! Meaning of output variables depend on the sign of `idx`.
  !! If it is -ve fill is a nested universe with uniIdx = -idx and uniRootId = id
  !! If it is +ve fill is material cell with matIdx = idx and uniqueId = id
  !!
  !! Args:
  !!   uniRootId [in] -> Location in array of the universe
  !!   localId [in]   -> Id of the local cell in the universe
  !!   idx [out]      -> matIdx or -uniIdx of the content
  !!   id [out]       -> UniqueId or uniRootId
  !!
  !! Errors:
  !!   If localId is too large or too smal, content from a different universe will be read
  !!   For invalid uniRootId any content may be returned
  !!
  elemental subroutine getFill(self, uniRootId, localId, idx, id)
    class(geomGraph), intent(in)   :: self
    integer(shortInt), intent(in)  :: uniRootId, localId
    integer(shortInt), intent(out) :: idx, id
    integer(shortInt)              :: idToUse

    ! Set values
    idToUse = uniRootId + localId - 1
    idx = self % array(idToUse) % idx
    id = self % array(idToUse) % id

  end subroutine getFill

  !!
  !! Return to uninitialised state
  !!
  elemental subroutine kill(self)
    class(geomGraph), intent(inout) :: self

    if(allocated(self % array)) deallocate(self % array)
    if(allocated(self % usedMats)) deallocate(self % usedMats)
    self % uniqueCells = 0

  end subroutine kill


  !!
  !! Build a shrunk representation
  !!
  !! Shrunk representation assigns a unique Id to every material local cell in each universe
  !! but does not distinguish between instances of the same universe (e.g. all pins in a lattice
  !! are considered the same pin from the point of view of unique Id)
  !!
  !! Args:
  !!   fills [in] -> Universe fill information. Must be valid as defined in `init` procedure.
  !!
  subroutine buildShrunk(self, fills)
    class(geomGraph), intent(inout)              :: self
    type(uniFills), intent(in)                   :: fills
    integer(shortInt)                            :: i, N, top, loc, fill, uniRootId
    integer(shortInt), dimension(:), allocatable :: unused
    type(intMap)                                 :: layed
    integer(shortInt), parameter                 :: NOT_FOUND = -7
    character(100), parameter                    :: Here = 'buildShrunk (geomGraph_class.f90)'

    ! Get unused univeres
    unused = fills % unusedUniverses()

    ! Allocate required space
    ! Is the number of local cells in all used universes
    N = 0
    do i = 1, size(fills % uni)
      if (.not. isIn(unused, fills % uni(i) % id)) N = N + size(fills % uni(i) % fill) ! Used universe

    end do
    allocate (self % array(N))

    ! Lay out universes -> start with root
    ! layed stores layedout universes as a map of idx -> location
    top = 1
    loc = 1
    call layed % add(fills % root, top)
    call layoutUniverse(self % array, top, fills, fills % root)

    ! Layout rest of the universes
    do while (loc <= size(self % array))
      ! Read content
      fill = self % array(loc) % idx

      ! Set uniRootId and layout if is universe
      if (fill < 0) then
        uniRootId = layed % getOrDefault(abs(fill), NOT_FOUND)
        if (uniRootId == NOT_FOUND) then ! Layout the universe
          uniRootId = top
          call layed % add(abs(fill), top)
          call layoutUniverse(self % array, top, fills, abs(fill))

        end if
        ! Store uniRootId
        self % array(loc) % id = uniRootId

      end if

      ! Increment location
      loc = loc + 1

    end do

    ! Check that top was reached
    if (top /= N + 1) call fatalError(Here, 'Did not reach the end of the location array. Top is: '//&
                                      numToChar(top)//' but should be: '//numToChar(N + 1))

    ! Set unique IDs -> Enumerate sinks
    call self % setUniqueIds()

  end subroutine buildShrunk

  !!
  !! Build an extended representation
  !!
  !! Extended representation changes the directed acyclic graph into a tree. Thus, local material
  !! cells in each instance of a universe have different uniqueIds assigned.
  !!
  !! Args:
  !!   fills [in] -> Universe fill information. Must be valid as defined in `init` procedure.
  !!
  subroutine buildExtended(self, fills)
    class(geomGraph), intent(inout) :: self
    type(uniFills), intent(in)      :: fills
    type(intMap)                    :: count
    integer(shortInt)               :: i, N, top, loc, fill, uniRootId
    character(100), parameter       :: Here = 'buildExtended (geomGraph_class.f90)'

    ! Calculate required space
    ! Loop over all universes and calculate space required for all their instances
    call fills % countInstances(count)
    N = 0
    do i = 1, size(fills % uni)
      N = N + size(fills % uni(i) % fill) * count % get(i)

    end do

    ! Allocate required space
    allocate(self % array(N))

    ! Layout universes starting with root
    top = 1
    loc = 1
    call layoutUniverse(self % array, top, fills, fills % root)

    ! Layout rest of universes by going down the tree
    do while (loc <= size(self % array))
      ! Read content
      fill = self % array(loc) % idx

      ! Set uniRootId and layout if is universe
      if (fill < 0) then
        uniRootId = top
        call layoutUniverse(self % array, top, fills, abs(fill))

        ! Store uniRootId
        self % array(loc) % id = uniRootId

      end if

      ! Increment location
      loc = loc + 1

    end do

    ! Check that top was reached
    if (top /= N + 1) call fatalError(Here, 'Did not reach the end of the location array. Top is: '//&
                                      numToChar(top)//' but should be: '//numToChar(N + 1))

    ! Set unique IDs -> Enumerate sinks
    call self % setUniqueIds()

  end subroutine buildExtended

  !!
  !! Loop through `array` to enumerate sinks of the graph (setting unique Ids)
  !!
  !! Also set:
  !!   * Number of uniqueIds
  !!   * List of matIdx used in the geometry
  !!
  !! Args:
  !!   None
  !!
  !! Errors:
  !!   Assumes `array` is allocated. Will likley segment if it isn't.
  !!
  subroutine setUniqueIds(self)
    class(geomGraph), intent(inout) :: self
    integer(shortInt)               :: i, cells, fill, pos
    type(intMap)                    :: matSet

    ! Loop over array
    cells = 0
    do i = 1, size(self % array)
      fill = self % array(i) % idx

      if (fill > 0) then ! It is material filling
        cells = cells + 1
        self % array(i) % id = cells
        call matSet % add(fill, 1)

      end if
    end do

    ! Set number of unique cells
    self % uniqueCells = cells

    ! Set used materials
    allocate (self % usedMats(matSet % length()))

    pos = 1
    i = matSet % begin()
    do while (i /= matSet % end())
      self % usedMats(pos) = matSet % atKey(i)
      pos = pos + 1
      i = matSet % next(i)

    end do

    ! Sort used materials
    call quickSort(self % usedMats)

  end subroutine setUniqueIds

  !!
  !! Put universe data on the array
  !!
  !! Used by diffrent build procedures
  !!
  !! Does not set uniRootID or uniqueID !
  !!
  !! Args:
  !!   array [inout]   -> Array of locations for universe data
  !!   freeLoc [inout] -> Index of the free first free location on the array. On exit set to the
  !!     new first free location.
  !!   fills [in]      -> Universe fill information
  !!   idx [in]     -> Index of the univese to lay out
  !!
  !! Errors:
  !!   fatalError if there is not enough data in the array
  !!
  subroutine layoutUniverse(array, freeLoc, fills, idx)
    type(location), dimension(:), intent(inout) :: array
    integer(shortInt), intent(inout)            :: freeLoc
    type(uniFills), intent(in)                  :: fills
    integer(shortInt), intent(in)               :: idx
    integer(shortInt)                           :: N
    character(100), parameter                   :: Here = 'layoutUniverse (geomGraph_class.f90)'

    ! Check universe idx
    if (idx < 1 .or. idx > size(fills % uni)) call fatalError(Here, &
    'Universe index: '//numToChar(idx)//' is invalid. Must be between 1 and '//numToChar(size(fills % uni))//'.')

    ! Check available space
    N = size(fills % uni(idx) % fill)
    if (freeLoc + N - 1 > size(array)) call fatalError(Here, 'Overflow of the location array when laying out universe &
    &(idx): '//numToChar(idx)//'.')

    ! Layout data
    array(freeLoc: freeLoc + N - 1) % idx = fills % uni(idx) % fill
    freeLoc = freeLoc + N

  end subroutine layoutUniverse

end module geomGraph_class